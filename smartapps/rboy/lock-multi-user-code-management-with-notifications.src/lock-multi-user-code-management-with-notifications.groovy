/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
/**
 * Add and remove user codes for locks
 *
 * Copyright RBoy
 * Redistribution of any changes or code is not allowed without permission
 * Version 2.1.5
 *
 * Change Log:
 * 2015-6-28 - Added support for lock notifications
 * 2015-9-26 - Added support to turn on/off switches when a user unlocks the door with a code
 * 2015-9-26 - Fixed a bug with mode changes when unlocking
 * 2015-9-18 - Added option to disarm Smart Home Monitor mode when unlocking, added option to select modes when notifying on manual unlock
 * 2015-9-2 - Fixed issue, don't run home phrase or change mode on manual unlock
 * 2015-9-1 - Improve text clarity
 * 2015-8-26 - Added support for running a phrase and changing modes when doors are unlocked successfully
 * 2015-7-25 - Potential fix for preventing the timers from dying
 * 2015-7-23 - Fix for monitoring not working after a mode change
 * 2015-7-22 - Added support for advanced scheduling options for individual users codes including permanent, one time, expiration and scheduled
 * 2015-7-22 - Use the standard "unknown" lock state to check for jammed
 * 2015-7-6 - Fixed issue with code expiry not working
 * 2015-6-18 - Added option to change delay between sending codes for users who have issues with communications
 * 2015-6-18 - Added notification for jammed door locks
 * 2015-6-17 - Fix for dynamic preferences not working after ST platform update
 * 2015-6-9 - Added support to disable push notifications only
 * 2015-5-27 - Added support for expiration dates
 * 2015-2-20 - Fixed issue with SMS not being sent
 * 2015-1-9 - Improve reliability with coding
 * 2015-1-1 - Created
 *
 */
definition(
		name: "Lock multi user code management with notifications",
		namespace: "rboy",
		author: "RBoy",
		description: "Add and Delete Multiple User Codes for Locks with code use notifications",
		category: "Safety & Security",
		iconUrl: "https://s3.amazonaws.com/smartapp-icons/Allstate/lock_it_when_i_leave.png",
		iconX2Url: "https://s3.amazonaws.com/smartapp-icons/Allstate/lock_it_when_i_leave@2x.png"
	  )

import groovy.json.JsonSlurper

preferences {
	page(name: "setupApp")
    page(name: "usersPage")
}

def setupApp() {
    dynamicPage(name: "setupApp", title: "Lock User Management", install: false, uninstall: true, nextPage: "usersPage") {    
        section("Select Lock(s)") {
            input "locks","capability.lock", title: "Lock", multiple: true
        }

		section("How many Users do you want to manage (common to all selected locks)?") {
        	input name: "maxUserNames", title: "Max users", type: "number", required: true, multiple: false,  submitOnChange: true
        }
        		
    	def phrases = location.helloHome?.getPhrases()*.label
    	if (phrases) {
       		phrases.sort()
			section("Door Unlock Actions (optional)") {
            	paragraph "Run these routines and/or change the mode when a user successfully unlocks the door"
				input name: "homePhrase", type: "enum", title: "Run Routine", required: false, options: phrases
                input name: "homeMode", type: "mode", title: "Change Mode To", required: false, multiple: false
                input name: "homeDisarm", type: "bool", title: "Disarm Smart Home Monitor", required: false
                paragraph "Turn on and/or off these switches/lights when a user successfully unlocks the door"
                input name: "turnOnSwitches", type: "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
                input name: "turnOffSwitches", type: "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
        	}        
		}
		
		section([mobileOnly:true]) {
			label title: "Assign a name for this SmartApp", required: false
		}

		section("Code Programming Option (optional)") {
            paragraph "Change this setting if all the user codes aren't being programmed on the lock correctly. This settings determines the time gap between sending each user code to the lock. If the codes are sent too fast, they may fail to be set properly."
            input name: "sendDelay", title: "Delay between codes (seconds):", type: "number", defaultValue: "15", required: false
        }
    }
}

def usersPage() {
	dynamicPage(name:"usersPage", title: "User Names, Codes and Notification Setup", uninstall: true, install: true) {

	section("Notification Options") {
        input name: "sms", title: "Send SMS notification to (optional):", type: "phone", required: false
        paragraph "Enable the below option if you DON'T want push notifications on your SmartThings phone app. This does not impact the SMS notifications."
        input name: "disableAllNotify", title: "Disable all push notifications", type: "bool", defaultValue: "false", required: true
    }
	
    section("Jammed Lock") {
    	input name: "jamNotify", title: "Notify on Lock Jam/Stuck", type: "bool"
    }

    section("Manual Unlock") {
    	paragraph "Get notifications when the door is unlocked manually (inside or outside)"
    	input name: "manualNotify", title: "Notify on Manual Unlock", type: "bool"
        input name: "manualNotifyModes", type: "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
    }

    section("Lock") {
    	paragraph "Get notifications when the door is locked (manually or automatically)"
    	input name: "lockNotify", title: "Notify on Lock", type: "bool"
        input name: "lockNotifyModes", type: "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
    }

	for (int i = 1; i <= settings.maxUserNames; i++) {
            def priorName = settings."userNames${i}"
            def priorCode = settings."userCodes${i}"
            def priorNotify = settings."userNotify${i}"
            def priorExpireDate = settings."userExpireDate${i}"
            def priorExpireTime = settings."userExpireTime${i}"
            def priorUserType = settings."userType${i}"
            def priorUserDayOfWeek = settings."userDayOfWeekA${i}"
            def priorUserStartTime = settings."userStartTimeA${i}"
            def priorUserEndTime = settings."userEndTimeA${i}"
        	def invalidDate = true
            log.debug "Initial $i Name: $priorName, Code: $priorCode, Notify: $priorNotify, ExpireDate: $priorExpireDate, ExpireTime: $priorExpireTime, UserType: $priorUserType, UserDayOfWeek: $priorUserDayOfWeek, UserStartTime: $userStartTime, UserEndTime: $userEndTime"
        	if (priorExpireDate) {
            	log.debug "Found expiry date in setup"
            	try {
                	Date.parse("yyyy-MM-dd", priorExpireDate)
                    invalidDate = false
                }
                catch (Exception e) {
                	log.debug "Invalid expiry date in setup"
                    invalidDate = true
                }
            }

            section("User Management Slot #${i}") {
                if (priorExpireDate && invalidDate == true) {
                    paragraph "INVALID DATE - PLEASE CHECK YOUR DATE FORMAT"
                } else if (priorExpireDate) {
                    def ed = Date.parse("yyyy-MM-dd", priorExpireDate)
                    paragraph "Code expiry date set for ${ed.format("EEE MMM dd yyyy")}"
                }

                if (priorExpireDate) {
                    if (!priorExpireTime) {
                        paragraph "PLEASE ENTER TIME FOR CODE EXPIRY"
                    }
                }

				if (priorCode) {
                    input name: "userNames${i}", description: "${priorName}", title: "Name", defaultValue: "${priorName}", type: "text", multiple: false, required: false
                    input name: "userCodes${i}", description: "${priorCode}", title: "Code", defaultValue: "${priorCode}", type: "text", multiple: false, required: false
                    input name: "userNotify${i}", title: "Notify", defaultValue: "${priorNotify}", type: "bool"
                    input name: "userType${i}",
                        type: "enum",
                        title: "Select User Type",
                        required: true,
                        multiple: false,
                        options: [
                            'Permanent',
                            'One time',
                            'Expire on',
                            'Scheduled'
                        ],
                        defaultValue: priorUserType,
                        submitOnChange: true
                } else {
                    input name: "userNames${i}", description: "Tap to set", title: "Name", type: "text", multiple: false, required: false
                    input name: "userCodes${i}", description: "Tap to set", title: "Code", type: "text", multiple: false, required: false
                    input name: "userNotify${i}", title: "Notify", type: "bool"
                    input name: "userType${i}",
                        type: "enum",
                        title: "Select User Type",
                        required: true,
                        multiple: false,
                        options: [
                            'Permanent',
                            'One time',
                            'Expire on',
                            'Scheduled'
                        ],
                        defaultValue: 'Permanent',
                        submitOnChange: true
                }
                
                switch (settings."userType${i}") {
                	case 'Expire on':
                        if (priorExpireDate) {
                            input name: "userExpireDate${i}", title: "Code expiration date (YYYY-MM-DD)", description: "Date on which the code should be deleted",  defaultValue: "${priorExpireDate}", type: "date", required: true,  submitOnChange: true
                        } else {
                            input name: "userExpireDate${i}", title: "Code expiration date (YYYY-MM-DD)", description: "Date on which the code should be deleted", type: "date", required: true,  submitOnChange: true
                        }

                        if (priorExpireTime) {
                            input name: "userExpireTime${i}", title: "Code expiration time", description: "(Touch here to set time) The code would be deleted within 5 minutes of this time", defaultValue: "${priorExpireTime}", type: "time", required: true,  submitOnChange: true
                        } else {
                            input name: "userExpireTime${i}", title: "Code expiration time", description: "(Touch here to set time) The code would be deleted within 5 minutes of this time", type: "time", required: true,  submitOnChange: true
                        }
                        break
                        
                    case 'Scheduled':
                        input "userStartTimeA${i}", "time", title: "Start Time", required: false
                        input "userEndTimeA${i}", "time", title: "End Time", required: false
                        input name: "userDayOfWeekA${i}",
                            type: "enum",
                            title: "Which day of the week?",
                            required: true,
                            multiple: true,
                            options: [
                                'All Week',
                                'Monday to Friday',
                                'Saturday & Sunday',
                                'Monday',
                                'Tuesday',
                                'Wednesday',
                                'Thursday',
                                'Friday',
                                'Saturday',
                                'Sunday'
                            ],
                            defaultValue: priorUserDayOfWeek
                    	break
                    
                    default:
	                    break
                }
            }
        } 
	} 
}

def installed()
{
	log.debug "Install Settings: $settings"
	appTouch()
}

def updated()
{
	log.debug "Update Settings: $settings"
	appTouch()
}

def doorHandler(evt)
{
	def data = []

	log.debug "Event name $evt.name, value $evt.value, device $evt.displayName, data $evt.data"
    
	if (evt.name == "lock") {
    	if (evt.value == "unlocked") {
            def isManual = false
	    	if ((evt.data == "") || (evt.data == null)) {  				// No extended data, must be a manual/keyed unlock
            	isManual = true
            }
            else {														// We have extended data, should be a coded unlock           	
	    		data = new JsonSlurper().parseText(evt.data) 
            	if ((data.usedCode == "") || (data.usedCode == null)) {	// If no usedCode data, treat as manual unlock
                	log.debug "Unknown extended data (${data}), treating as manual unlock"
                	isManual = true
           		 }
            }
            
            if (isManual) {
            	log.debug "$evt.displayName was unlocked manually"

                if (manualNotify && (manualNotifyModes ? manualNotifyModes.find{it == location.currentMode} : true)) {
                    if (!disableAllNotify) {
                        sendPush "$evt.displayName was unlocked manually"
                    } else {
                        sendNotificationEvent("$evt.displayName was unlocked manually")
                    }
                    if (sms) {
                        sendSms(sms, "$evt.displayName was unlocked manually")
                    }
                    return
                }
            }
            else {
            	Integer i = data.usedCode as Integer
                def userName = settings."userNames${i}"
                def notify = settings."userNotify${i}"
                
                log.debug "Lock $evt.displayName unlocked by $userName, notify $notify"
                
                if (homeMode) {
                	log.info "Changing mode to ${settings.homeMode}"
                    sendNotificationEvent("$evt.displayName was unlocked successfully, changing mode to ${settings.homeMode}")
                    if (location.modes?.find{it.name == homeMode}) {
                        setLocationMode(homeMode)
                    }  else {
                        log.warn "Tried to change to undefined mode '${homeMode}'"
                    }
                }
                
                if (homePhrase) {
                	log.info "Running unlock Phrase ${settings.homePhrase}"
                    sendNotificationEvent("$evt.displayName was unlocked successfully, running ${settings.homePhrase}")
                    location.helloHome.execute(settings.homePhrase)
                }

                if (homeDisarm) {
                	log.info "Disarming Smart Home Monitor"
                    sendNotificationEvent("$evt.displayName was unlocked successfully,  disarming Smart Home Monitor")
                    sendLocationEvent(name: "alarmSystemStatus", value: "off")
                }
                
                if (turnOnSwitches) {
                	log.info "Turning on switches $turnOnSwitches"
                    turnOnSwitches?.on()
                }
                
                if (turnOffSwitches) {
                	log.info "Turning off switches $turnOffSwitches"
                    turnOffSwitches?.off()
                }
                                
				// Check for one time codes and disable them if required
                state.usedOneTimeCodes.add(i as String) // mark the user slot used
                expireCodeCheck() // Check the expired code and remove from lock

                if (notify) {
                    if (userName == null) {
                    	if (!disableAllNotify) {
                        	sendPush "$evt.displayName was unlocked by Unknown User"
                        } else {
                            sendNotificationEvent("$evt.displayName was unlocked by Unknown User")
                        }
                        if (sms) {
                        	sendSms(sms, "$evt.displayName was unlocked by Unknown User")
                        }
                    }
                    else {
                    	if (!disableAllNotify) {
                        	sendPush "$evt.displayName was unlocked by $userName"
                        } else {
                            sendNotificationEvent("$evt.displayName was unlocked by $userName")
                        }
                        if (sms) {
                        	sendSms(sms, "$evt.displayName was unlocked by $userName")
                        }
                    }
                }
            }
        }
        else if (evt.value == "locked") {
            log.debug "$evt.displayName was locked"

            if (lockNotify && (lockNotifyModes ? lockNotifyModes.find{it == location.currentMode} : true)) {
                if (!disableAllNotify) {
                    sendPush "$evt.displayName was locked"
                } else {
                    sendNotificationEvent("$evt.displayName was locked")
                }
                if (sms) {
                    sendSms(sms, "$evt.displayName was locked")
                }
            }
        }
        else if (evt.value == "unknown") {
            log.debug "Lock $evt.displayName Jammed!"
            if (notify) {
                if (!disableAllNotify) {
                    sendPush "$evt.displayName lock is Jammed!"
                } else {
                    sendNotificationEvent("$evt.displayName lock is Jammed!")
                }
                if (sms) {
                    sendSms(sms, "$evt.displayName lock is Jammed!")
                }
            }        	
        }
    }
}
                
def appTouch() {
	unschedule() // clear all pending updates
    unsubscribe()
	subscribe(location, modeChangeHandler)
    subscribe(locks, "lock", doorHandler)
    
    state.usedOneTimeCodes = []
    state.lockList = []
    state.activeScheduledCodes = []
    state.expiredCodes = []

	for (lock in locks) {
    	state.lockList.add(lock.id) // reset the state for each lock to be processed
        log.debug "Adding $lock id ${lock.id} to unprocessed locks list ${state.lockList}"
    }
    state.nextCode = 1 // set next code to be set
    
    runIn(1, updateCodes) // Updates codes
    
    log.debug "Scheduling code updates starting with code $state.nextCode in 1 second"
}

def updateCodes() {
	for (lock in locks) {
		if (state.lockList.contains(lock.id)) { // this lock codes hasn't been completely initiated
        	log.debug "Check for pending code updates for $lock"
	        if (state.nextCode <= settings.maxUserNames) {
            	log.debug "Updating code $state.nextCode on $lock"
                def name = settings."userNames${state.nextCode}" // Get the name for the slot
                def code = settings."userCodes${state.nextCode}" // Get the code for the slot
                def notify = settings."userNotify${state.nextCode}" // Notification setting
                def userType = settings."userType${state.nextCode}" // User type
                def expDate = settings."userExpireDate${state.nextCode}" // Get the expiration date
                def expTime = settings."userExpireTime${state.nextCode}" // Get the expiration time
                def userDayOfWeekA = settings."userDayOfWeekA${state.nextCode}" // Scheduling Days of week A
                def userStartTimeA = settings."userStartTimeA${state.nextCode}" ? (new Date(timeToday(settings."userStartTimeA${state.nextCode}", location.timeZone).time)).format("HH:mm z", location.timeZone) : "" // Scheduling start time A
                def userEndTimeA = settings."userEndTimeA${state.nextCode}" ? (new Date(timeToday(settings."userEndTimeA${state.nextCode}", location.timeZone).time)).format("HH:mm z", location.timeZone) : "" // Scheduling end time A
                def user = state.nextCode as Integer // which user slot are we using 
				def doAdd = false // by default we dont' add codes
                
                // Check the code expiration
                switch (userType) {
                    case 'Expire on':
                        if (expDate && expTime) {
                            def midnightToday = timeToday("2000-01-01T00:00:00.000-0000", location.timeZone)
                            def expT = (timeToday(expTime, location.timeZone).time - midnightToday.time)
                            String dst = location.timeZone.getDisplayName(location.timeZone.inDaylightTime(new Date(now())), TimeZone.SHORT) // Keep current timezone
                            def expD = Date.parse("yyyy-MM-dd Z", expDate + " " + dst).toCalendar()
                            def exp = expD.getTimeInMillis() + expT
                            def expStr = (new Date(exp)).format("EEE MMM dd yyyy HH:mm z", location.timeZone)
                            if (exp > now()) {
	                            sendNotificationEvent("$lock user $user $name's code is set to expire on $expStr")
                            	log.debug "$lock user $user $name's code is set to expire on $expStr"
                            	doAdd = true // we need to add the code
                            } else {
                            	if (!state.expiredCodes.contains(user as String)) {
                                	state.expiredCodes.add(user as String)
		                            log.info "$lock user $user $name expired on $expStr"
                                } else {
                                    log.error "$lock user $user $name is already tracked as expired"
                                }
                                sendNotificationEvent("$lock user $user $name's code expired on $expStr")
							}
                        } else {
                            log.error "User $user $name set to Expire but does not have a Expiration Date: $expDate or Time: $expTime"
                        }
                        break

                    case 'One time':
                    	log.info "$lock user $user $name is a one time code"
                    	sendNotificationEvent("$lock user $user $name is a one time code")
                        doAdd = true // the code
                    	break
                        
                    case 'Scheduled':
		            	if (checkSchedule(user, "A")) { // Within operating schedule
                            if (state.activeScheduledCodes.contains(user as String)) {
                                log.error "$lock scheduled user $user $name is already tracked. It is scheduled to work between $userDayOfWeekA: $userStartTimeA to $userEndTimeA"
                            } else {
                                log.info "$lock user $user $name is scheduled to work between $userDayOfWeekA: $userStartTimeA to $userEndTimeA"
                                state.activeScheduledCodes.add(user as String) // track scheduled users who are added
                            }
                            doAdd = true // Add the user
                            sendNotificationEvent("$lock user $user $name is scheduled to work between $userDayOfWeekA: $userStartTimeA to $userEndTimeA")
                        } else {
	                        state.activeScheduledCodes.remove(user as String) // track scheduled users who are added
                            log.info "$lock user $user $name is outside operating schedule between $userDayOfWeekA: $userStartTimeA-$userEndTimeA"
                            sendNotificationEvent("$lock user $user $name is outside operating schedule between $userDayOfWeekA: $userStartTimeA to $userEndTimeA")
                        }
                        break
                        
                    case 'Permanent':
                    	doAdd = true // add the code
                        break
                        
                    default:
                    	log.error "Invalid user type $userType, user $user $name"
                    	sendNotificationEvent("Invalid user type $userType, user $user $name")
                        break
                }

                if ((code != null) && doAdd) { // We have a code and it is not expired/within schedule, update or set the code in the slot
                    lock.setCode(user, code)
                    log.info "$lock added user: $user, code: $code, name: $name"
                    sendNotificationEvent("$lock added $name to user $user")
                } else { // No code, delete the slot
                    lock.deleteCode(user)
                    log.info "$lock deleted user: $user"
                    sendNotificationEvent("$lock deleted user: $user")
                }
                
				state.nextCode = state.nextCode + 1 // move onto the next code
				log.debug "Scheduled next code update in ${sendDelay > 0 ? sendDelay : 15} seconds"
                startTimer((sendDelay > 0 ? sendDelay : 15), updateCodes) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work
                return
            }
            
            state.lockList.remove(lock.id) // we are done with this lock
            state.nextCode = 1 // reset back to 1 for the next lock
            log.debug "$lock id $lock.id code updates complete, unprocessed locks ${state.lockList}, reset next code update to $state.nextCode"
        }
    }
    
    expireCodeCheck() // start the expired code check routine
}

def expireCodeCheck() {
	log.debug "ExpireCodeCheck called"

	for (int i = 1; i <= settings.maxUserNames; i++) {
        def name = settings."userNames${i}" // Get the name for the slot
        def code = settings."userCodes${i}" // Get the code for the slot
        def notify = settings."userNotify${i}" // Notification setting
        def userType = settings."userType${i}" // User type
        def expDate = settings."userExpireDate${i}" // Get the expiration date
        def expTime = settings."userExpireTime${i}" // Get the expiration time
        def userDayOfWeekA = settings."userDayOfWeekA${i}" // Scheduling Days of week A
        def userStartTimeA = settings."userStartTimeA${i}" ? (new Date(timeToday(settings."userStartTimeA${i}", location.timeZone).time)).format("HH:mm z", location.timeZone) : "" // Scheduling start time A
        def userEndTimeA = settings."userEndTimeA${i}" ? (new Date(timeToday(settings."userEndTimeA${i}", location.timeZone).time)).format("HH:mm z", location.timeZone) : "" // Scheduling end time A

		switch (userType) {
        	case 'Expire on':
                if (expDate && expTime) {
                    def midnightToday = timeToday("2000-01-01T00:00:00.000-0000", location.timeZone)
                    def expT = (timeToday(expTime, location.timeZone).time - midnightToday.time)
                    String dst = location.timeZone.getDisplayName(location.timeZone.inDaylightTime(new Date(now())), TimeZone.SHORT) // Keep current timezone
                    def expD = Date.parse("yyyy-MM-dd Z", expDate + " " + dst).toCalendar()
                    def exp = expD.getTimeInMillis() + expT
                    def expStr = (new Date(exp.value)).format("EEE MMM dd yyyy HH:mm z", location.timeZone)
                    if (exp < now()) {
                        if (!state.expiredCodes.contains(i as String)) {
                            state.expiredCodes.add(i as String)
                            def user = i as Integer // Convert to integer to be sure
                            for (lock in locks) {
                                lock.deleteCode(user)
                                log.info "$lock deleted expired user $user $name"
                                sendNotificationEvent("$lock deleted expired user $user $name")
                            }
                    
                            log.debug "Scheduled next code check in ${sendDelay > 0 ? sendDelay : 15} seconds"
                            startTimer((sendDelay > 0 ? sendDelay : 15), expireCodeCheck) // schedule the next code removal after a few seconds otherwise it overloads locks and doesn't work
                            return
                        } else {
                            log.trace "User $i $name is already tracked as expired"
                        }
                    }
                } else {
                	log.error "User $i $name set to Expire but does not have a Expiration Date: $expDate or Time: $expTime"
                }
                break
                
			case 'One time':
            	if (state.usedOneTimeCodes.contains(i as String)) {
                    def user = i as Integer // Convert to integer to be sure
                    state.usedOneTimeCodes.remove(i as String)
                    for (lock in locks) {
                        lock.deleteCode(user)
                        log.info "$lock deleted one time user $user $name"
                        sendNotificationEvent("$lock deleted one time user $user $name")
                    }

                    log.debug "Scheduled next code check in ${sendDelay > 0 ? sendDelay : 15} seconds"
                    startTimer((sendDelay > 0 ? sendDelay : 15), expireCodeCheck) // schedule the next code removal after a few seconds otherwise it overloads locks and doesn't work
                    return
				} else {
                	log.debug "User $i $name is a one time code but it has not been used yet"
                }
            	break
                
			case 'Scheduled':
            	if (checkSchedule(i, "A")) { // Within operating schedule
                    if (state.activeScheduledCodes.contains(i as String)) {
                    	log.trace "Scheduled user $i $name is already active, not adding again"
                    } else {
                        def user = i as Integer // Convert to integer to be sure
                        state.activeScheduledCodes.add(i as String) // track scheduled users who are added
                        for (lock in locks) {
                            lock.setCode(user, code)
	                        log.info "$lock added $name to user $user, code: $code, because it is scheduled to work between $userDayOfWeekA: $userStartTimeA to $userEndTimeA"
	                        sendNotificationEvent("$lock added $name to user $user because it is scheduled to work between $userDayOfWeekA: $userStartTimeA to $userEndTimeA")
                        }

                        log.debug "Scheduled next code check in ${sendDelay > 0 ? sendDelay : 15} seconds"
                        startTimer((sendDelay > 0 ? sendDelay : 15), expireCodeCheck) // schedule the next code removal after a few seconds otherwise it overloads locks and doesn't work
                        return
                    }
                } else { // Outside operating schedule
                    if (!state.activeScheduledCodes.contains(i as String)) {
                    	log.trace "Scheduled user $i $name is already inactive, not removing again"
                    } else {
                        def user = i as Integer // Convert to integer to be sure
                        state.activeScheduledCodes.remove(i as String) // track scheduled users who are added
                        for (lock in locks) {
                            lock.deleteCode(user)
	                        log.info "$lock deleted expired user $user $name because it is scheduled to work between $userDayOfWeekA: $userStartTimeA to $userEndTimeA"
	                        sendNotificationEvent("$lock deleted expired user $user $name because it is scheduled to work between $userDayOfWeekA: $userStartTimeA to $userEndTimeA")
                        }

                        log.debug "Scheduled next code check in ${sendDelay > 0 ? sendDelay : 15} seconds"
                        startTimer((sendDelay > 0 ? sendDelay : 15), expireCodeCheck) // schedule the next code removal after a few seconds otherwise it overloads locks and doesn't work
                        return
                    }
                }
                break
                
			case 'Permanent':
			default:
                break
        }
    }
    
    startTimer(5*60, expireCodeCheck) // schedule the next code check in 5 minutes
}

def startTimer(seconds, function) {
	def runTime = new Date(now() + (seconds * 1000)) // for runOnce
    log.trace "Scheduled to run $function at $runTime"
	runOnce(runTime, function, [overwrite: true]) // runIn isn't reliable, runOnce is more reliable, but only runIn supports overwrite:false to preserve existing function calls pending from runEveryXMinutes
}

private checkSchedule(def i, def x) {
	log.debug("Checking operating schedule $x for user $i")
    
    def doChange = false
    Calendar localCalendar = Calendar.getInstance(location.timeZone);
    int currentDayOfWeek = localCalendar.get(Calendar.DAY_OF_WEEK);
    def currentTime = now()

    // some debugging in order to make sure things are working correclty
    log.debug "Current time: ${(new Date(currentTime)).format("EEE MMM dd yyyy HH:mm z", location.timeZone)}"

	// Check if we are within operating times
    if (settings."userStartTime${x}${i}" != null && settings."userEndTime${x}${i}" != null) {
        def scheduledStart = timeToday(settings."userStartTime${x}${i}", location.timeZone).time
        def scheduledEnd = timeToday(settings."userEndTime${x}${i}", location.timeZone).time

    	log.debug("Operating ${settings."userStartTime${x}${i}"} ${(new Date(scheduledStart)).format("HH:mm z", location.timeZone)}, ${settings."userEndTime${x}${i}"} ${(new Date(scheduledEnd)).format("HH:mm z", location.timeZone)}")

		if (currentTime < scheduledStart || currentTime > scheduledEnd) {
            log.info("Outside operating time schedule")
            return false
        }
    }

	// Check the condition under which we want this to run now
    // This set allows the most flexibility.
    log.debug("Operating DOW(s): ${settings."userDayOfWeek${x}${i}"}")

    if(settings."userDayOfWeek${x}${i}" == null) {
    	log.error "Invalid Day of week ${settings."userDayOfWeek${x}${i}"}"
    } else if(settings."userDayOfWeek${x}${i}".contains('All Week')) {
            doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Monday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.MONDAY) {
            doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Tuesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.TUESDAY) {
            doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Wednesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.WEDNESDAY) {
            doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Thursday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.THURSDAY) {
            doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Friday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.FRIDAY) {
            doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Saturday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SATURDAY) {
            doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Sunday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SUNDAY) {
            doChange = true
    }


    // If we have hit the condition to schedule this then lets do it
    if(doChange == true){
    	log.info("Within operating schedule")
        return true
    }
    else {
        log.info("Outside operating schedule")
        return false
    }
}

// Handle mode changes, reinitialize the current temperature and timers after a mode change, this is to workaround the issue of the last timer firing while in a non running mode, resume operations when supported modes are set
def modeChangeHandler(evt) {
	log.debug "Lock Mgmt reinitializing on mode change notification, new mode $evt.value"
	//sendNotificationEvent("$Lock Mgmt reinitializing on mode change notification, new mode $evt.value")
	expireCodeCheck() // kick start the expireCodeCheck sequence
}